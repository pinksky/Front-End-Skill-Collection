# 《MongoDB权威指南》学习笔记

### 第二章 入门

#### 文档
- Mongodb的文档区分大小写
- Mongodb的文档不能有重复的键

#### 数据类型
- Json只有6种数据类型: null，数字，字符串，布尔值，数组，对象
- Mongodb的数字
	+ Mongodb中有三种数字类型(32位整数、64位整数和64位浮点数)，Mongodb shell会绕过Javascript的限制，默认情况下shell中的数字都被Mongodb当做双精度数
- 日期
	+ 在Javascript中，Date对象通常用做Mongodb的日期类型，创建一个新的Date对象的时候，通常会调用new Date()而不只是Date()。调用构造函数(不包括new)会返回日期的字符串表示，而不是真正的Date对象。
- 内嵌文档
	+ 内嵌文档使用得当会使得信息表现更加自然，通常也更加高效。但是内嵌文档也有坏处，因为这样Mongodb会存储更多重复的数据，这是违反规范的。如果有一个内嵌文档的值被使用很多次，在Mongodb里面只能重复出现，修改也要一个个修改。

### 第三章 创建、更新及删除文档

#### 插入并保存文档
- 插入的原理和作用
	+ 当执行插入的时候，使用的驱动程序会将数据转换成BSON格式，然后将其送入数据库。数据库解析BSON，检验是否包含"_id"键，并且文档是否超过4M，除此之外，不做别的验证。
- Mongodb插入的时候并不执行代码，所以这一块没有注入攻击的可能。
#### 删除文档
- `db.users.remove()`会删除user集合中的所有文档，但不会删除集合本身，原油的索引也会保留。
- 删除操作是永久性的，不能撤销，也不能恢复。

#### 更新文档
```
	db.collection.update(
	   <query>,
	   <update>,
	   {
	     upsert: <boolean>,
	     multi: <boolean>,
	     writeConcern: <document>
	   }
	)
```
- 文档存入数据库之后，就可以使用Update方法来修改它。update有两个参数，一个是查询文档，一个是修改器文档，描述对找到的文档做哪些修改。
- 通常文档只会有一部分需要更新，利用原子的更新修改器，可以使得部分更新极为高效。
	+ `$set`修改器
	用来指定一个键的值，如果这个键不存在，则创建它。
	```
		db.users.update({"name": "yuanzm"}, {$set: {"age": 21}});
	```
	+ `$inc`修改器
	用来增加已有的键值，或者键不存在的时候创建一个键。对于分析数据、因果关系、投票或者其他有数值变化的地方，这个方法显得非常方便。
	```
		db.users.update({"name": "yuanzm"}, {$inc: {"age": 1}});
	```
	+ `$push`数组修改器
	如果指定的键存在，$push会向已有的数组末尾添加一个元素。要是数组不存在，会创建一个数组。
	```
		db.users.update({"name": "yuanzm"}, {$push: {"books": "javascript"}});
	```
	$push或者其他数组修改器是推荐使用的，有些场合还是非常必要的，但是一定要留心这些更新的利弊，如果$push成为性能瓶颈，可以将内嵌数组独立出来，放到单独的一个集合里面。
- 默认情况下，更新文档只能对符合查询条件的第一个文档执行操作。要使所有匹配的文档都得到更新，可以设置update的第四个参数为true。

#### 请求和连接
数据库会为每一个Mongodb数据库连接创建一个队列，存放这个连接的请求。当客户端发送一个请求，会放到队列的末尾。只有队列中的请求都执行完毕，后续的请求才会执行。所以从单个连接就可以了解整个数据库，并且总是能读到自己写的东西
注意，每个连接都有自己独立的队列，要是打开两个shell，就有两个数据连接。在一个shell中插入，只有在另一个shell中进行查询并不一定能够得到插入的文档。然而在同一个shell中进行的插入是一定可以查询到的。

### 第四章 查询

#### 返回指定的键
有时候并不希望文档中的所有键都返回，遇到这种情况，可以通过给find或者findOne的第二个参数来指定想要的键，这样既会节省传输的数据量，又能节省客户端解码文档的时间和内存消耗。
```
	db.users.find({}, {"_id": 0});
```
#### 查询数组
查询数组的元素也是非常容易的。数组绝大数情况下可以这样理解：每一个数组的元素都是整个键的值。例如如果数组是这样一个水果清单，比如：
```
	db.food.insert({"fruit": ["apple", "banana", "peach"]});
	db.food.find({"fruit": "apple"}); // 有效
```
- `$all`
如果要通过多个元素来匹配数组，就要用到`$all`了。如果要匹配既包含apple又包含peach的数组，就需要像下面这样查询
```
	db.food.find({"fruit": {"$all": ["apple", "paech"]}});
```
其中，顺序是无关紧要的。

### 第五章 索引
创建索引的缺点每次插入、更新和删除时都会产生额外的开销。这是因为数据库不但需要执行这些操作，还需要将这些操作在集合的索引中标记。因此，要尽可能的少创建索引。每个集合默认的索引个数最大限制为64个。
一定不要索引每一个键，因为这会导致插入非常慢，还会占用很多空间。

